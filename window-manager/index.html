<!DOCTYPE html>
<html>
  <head>
    <title>Graphics: from pixels to windows – SnowflakeOS's blog</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="
With SnowflakeOS starting to have more of the pieces a proper hobby OS should have, it was time to make this state of affair visible from the outside. Graphics!
Ironically, by switching away from text mode, we lose the immediate ability to print text, but as you’ll see we’re going to get it all back. At some point anyway; what’s presented here is  the beginning of this process.

" />
    <meta property="og:description" content="
With SnowflakeOS starting to have more of the pieces a proper hobby OS should have, it was time to make this state of affair visible from the outside. Graphics!
Ironically, by switching away from text mode, we lose the immediate ability to print text, but as you’ll see we’re going to get it all back. At some point anyway; what’s presented here is  the beginning of this process.

" />
    
    <meta name="author" content="Johan Manuel" />

    
    <meta property="og:title" content="Graphics: from pixels to windows" />
    <meta property="twitter:title" content="Graphics: from pixels to windows" />
    


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Johan Manuel - Developer of SnowflakeOS" href="/feed.xml" />
    
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://avatars1.githubusercontent.com/u/6154077?s=460&v=4" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Johan Manuel</a></h1>
            <p class="site-description">Developer of SnowflakeOS</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Graphics: from pixels to windows</h1>

  <div class="entry">
    <p><img src="/assets/kerning.png" alt="Current state of the GUI" class="thumbnail" title="The background is generated by setting the ith pixel to 'i | i*512 | i % 512'" />
With SnowflakeOS starting to have more of the pieces a proper hobby OS should have, it was time to make this state of affair visible from the outside. Graphics!
Ironically, by switching away from text mode, we lose the immediate ability to print text, but as you’ll see we’re going to get it all back. At some point anyway; what’s presented here is  the beginning of this process.</p>

<h2 id="the-boring-part-switching-video-mode">The boring part: switching video mode</h2>

<p>A prerequisite to doing anything is to get the screen in a state in which we can access individual pixels instead of just characters. The traditional way of doing so is to manually call BIOS functions to get available modes and choose one while the computer is still executing in real mode. In the case of SnowflakeOS, this isn’t practical: the kernel is loaded by GRUB, so it starts executing in protected mode, where we can’t access BIOS functions. There are two ways around that:</p>
<ul>
  <li>Enable virtual 8086 mode - an emulation of real mode - long enough to set the video mode, then get back to protected mode</li>
  <li>Ask GRUB to set the correct video mode before loading our kernel</li>
</ul>

<p>The first option is the one most advertised on the osdev wiki, and at first it was the only one I knew about. Switching to virtual 8086 mode is easy enough, it involves faking an interrupt return in order to set the <code class="language-plaintext highlighter-rouge">VM</code> bit in the <code class="language-plaintext highlighter-rouge">eflags</code> register, kind of how we <a href="https://github.com/29jm/SnowflakeOS/blob/738c417d87460b82eafc2f9718ebc59b6c449de9/kernel/src/sys/proc.c#L202-L223">switched to ring 3</a> for the first usermode process. I don’t known much about this mode given that I didn’t end up implementing support for it, but there were several issues I could see taking a lot of work to resolve: how does execution get back to the kernel? do I have to implement support for virtual 8086 tasks within my scheduler? do I need to compile the executing code in 16-bit mode? what happens to my kernel stack?…
Far too much work that feels like writing boilerplate code. I was very happy to discover an alternative.</p>

<p>The second option is simpler by a long shot. Asking GRUB to set the video mode is as easy as modifying the <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Header-layout">multiboot header</a> that’s sitting at the very beginning of our kernel binary:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">section</span> <span class="p">.</span><span class="n">multiboot</span>
    <span class="p">.</span><span class="kt">long</span> <span class="n">MAGIC</span>
    <span class="p">.</span><span class="kt">long</span> <span class="n">FLAGS_PAGE_ALIGN</span> <span class="o">|</span> <span class="n">FLAGS_MEMORY</span> <span class="o">|</span> <span class="n">FLAGS_GRAPHICS</span>
    <span class="p">.</span><span class="kt">long</span> <span class="o">-</span><span class="p">(</span><span class="n">MAGIC</span> <span class="o">+</span> <span class="n">FLAGS</span><span class="p">)</span> <span class="err">#</span> <span class="n">checksum</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mh">0x00000000</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mh">0x00000000</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mh">0x00000000</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mh">0x00000000</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mh">0x00000000</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mi">0</span>    <span class="err">#</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="n">linear</span> <span class="n">framebuffer</span><span class="p">,</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">text</span> <span class="n">mode</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mi">1024</span> <span class="err">#</span> <span class="n">width</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mi">768</span>  <span class="err">#</span> <span class="n">height</span>
    <span class="p">.</span><span class="kt">long</span> <span class="mi">32</span>   <span class="err">#</span> <span class="n">bpp</span>
</code></pre></div></div>
<p>The downside is that you can’t choose a resolution or bit depth dynamically: if the precise mode you asked for isn’t available, GRUB will choose one for you. That sounds like a fair tradeoff to me.</p>

<p>GRUB gives us a framebuffer described by the following entries in the <a href="https://www.gnu.org/software/grub/manual/multiboot/multiboot.html#Boot-information-format">multiboot structure</a>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">address</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">pitch</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">height</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">bpp</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">type</span><span class="p">;</span>
    <span class="c1">// Technically, the layout of the following fields depends on the value of `type`</span>
    <span class="kt">uint8_t</span> <span class="n">red_position</span><span class="p">,</span> <span class="n">red_mask_size</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">green_position</span><span class="p">,</span> <span class="n">green_mask_size</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">blue_position</span><span class="p">,</span> <span class="n">blue_mask_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">fb_info_t</span><span class="p">;</span>
</code></pre></div></div>
<p>Some fields are a bit obscure here: <code class="language-plaintext highlighter-rouge">pitch</code> is the number of bytes per rows, <code class="language-plaintext highlighter-rouge">bpp</code> is the bit depth, <code class="language-plaintext highlighter-rouge">type</code> should be 0 (otherwise GRUB gave us text buffer), and the color fields indicate the pixel layout.<br />
I think the reason <code class="language-plaintext highlighter-rouge">pitch</code> is given here is that there can be padding bytes between each “line” of pixels, so it may not necessarily equal <code class="language-plaintext highlighter-rouge">width*bpp/8</code>, though it does for QEMU and Bochs.</p>

<p>The <code class="language-plaintext highlighter-rouge">address</code> field refers to a physical address, so we mustn’t forget to map it after enabling paging. For a 1024x768x32 mode, the framebuffer is 3 MiB large, so it’s not exactly a trivial allocation in the kernel heap, where I chose to map it. An alternative would be to map it on request in processes’ address spaces where addresses are aplenty, but I’d rather not expose it raw to usermode applications.</p>

<h2 id="rocking-that-framebuffer">Rocking that framebuffer</h2>

<h3 id="plotting-pixels">Plotting pixels</h3>

<p>Now that we have an address to write to, plotting a pixel is a matter of computing its offset and knowing its format. The address of the pixel at (x, y) is given by</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">pitch</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">bpp</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
</code></pre></div></div>

<p>Once you’re there, all that remains is implementing some drawing primitives. Rectangles, lines, borders…<br />
Line drawing algorithms are somewhat convoluted, there are several and I ended up implementing Bresenham’s algorithm which is well-detailed on <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">wikipedia</a>.</p>

<h3 id="getting-our-text-back-the-psf-format">Getting our text back, the PSF format</h3>

<figure>
    <img src="/assets/psf_font.png" />
    <figcaption>128 characters ought to be enough for anybody</figcaption>
</figure>

<p>The most straightforward way to draw text has to be through bitmap fonts. In a bitmap font, a character is represented by an array of bits, with say each <code class="language-plaintext highlighter-rouge">n</code> bits representing a line of pixels in the character. For example, here’s a very crude ‘O’:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>
</code></pre></div></div>
<p>It turns out there’s a dead easy format still in wide use: <a href="https://www.win.tue.nl/~aeb/linux/kbd/font-formats-1.html">PSF</a>, for <em>PC Screen Font</em>, used by virtual consoles in Linux.</p>

<p>There are two versions of this format:</p>
<ul>
  <li>PSF1: fixed number of characters, 8 pixels wide, variable character height</li>
  <li>PSF2: variable number of characters, variable character size</li>
</ul>

<p>Both formats have a short header at the beginning of the file. On my machine, all fonts in <code class="language-plaintext highlighter-rouge">/usr/share/kbd/consolefonts</code> seem to be PSF1. In this format, the header looks like this:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">magic</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">uint8_t</span> <span class="n">mode</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span> <span class="n">font_header_t</span><span class="p">;</span>
</code></pre></div></div>
<p>Where <code class="language-plaintext highlighter-rouge">magic</code> should equal <code class="language-plaintext highlighter-rouge">0x36, 0x04</code>, <code class="language-plaintext highlighter-rouge">mode</code> contains information about the number of characters and unicode support (which I haven’t dealt with), and <code class="language-plaintext highlighter-rouge">height</code> is the height of each character in pixels.<br />
The actual font starts right after the header, so the offset of an ASCII character <code class="language-plaintext highlighter-rouge">c</code> in the font file, in bytes, is given by</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">font_header_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">height</span><span class="p">;</span>
</code></pre></div></div>
<p>Drawing a character is then a matter of checking individual bits, line by line, and plotting pixels accordingly.<br />
I extracted the font used in my console with</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setfont</span> <span class="o">-</span><span class="n">o</span> <span class="n">font</span><span class="p">.</span><span class="n">psf</span><span class="p">;</span> <span class="n">xxd</span> <span class="o">-</span><span class="n">i</span> <span class="n">font</span><span class="p">.</span><span class="n">psf</span> <span class="o">&gt;</span> <span class="n">font</span><span class="p">.</span><span class="n">h</span>
</code></pre></div></div>
<p>and used that one. The characters are those shown in the image above, in 8x16 format.</p>

<h2 id="from-rectangles-to-windows-a-window-manager">From rectangles to windows: a window manager</h2>

<p>Until now we’ve only drawn shapes the the screen. What turns a shape into a window? By my definition, a window manager (WM).</p>

<h3 id="design">Design</h3>

<p>In SnowflakeOS, the window manager handles only two concepts:</p>
<ul>
  <li><strong>windows</strong>: those are rectangular buffers with an (x, y) position, a z-order and a few flags</li>
  <li><strong>focus</strong>: who gets user input?</li>
</ul>

<p>It knows nothing of window decorations, concepts of desktop background, taskbar, or even mouse pointer. Those things will be windows, managed by userspace applications, clients of the WM.<br />
As far as I know, this minimalist approach is somewhat close to how weston works, a window manager for wayland.</p>

<p>The WM needs to communicate with applications wishing to use windows. Usually, the WM is a userspace program, so this is done using a form of inter-process communication. I decided against implementing such a system for now - I tried my hand at a virtual file system, pipes and all, but I felt I didn’t have enough background to properly design anything, or to implement the usual APIs of Unixes.<br />
Thus, I implemented the WM in the kernel, and programs communicate with it through system calls. It’s a pretty crude and non-general way of communicating, but it works for now.</p>

<h3 id="the-userspace-api">The userspace API</h3>

<p>I introduced a library for SnowflakeOS programs, thoughtfully named <a href="https://github.com/29jm/SnowflakeOS/blob/738c417d87460b82eafc2f9718ebc59b6c449de9/snow/include/snow.h">snow</a>, which wraps system calls in pretty C functions.<br />
It offers a <code class="language-plaintext highlighter-rouge">snow_open_window</code> function which allocates a buffer of the window’s size. Drawing functions then write to that buffer, and the program asks for that window to be drawn to screen by calling <code class="language-plaintext highlighter-rouge">snow_render_window</code>. There are no GUI functions right now - only mockups - but they’ll sit between those two calls. Closing the window is then done though <code class="language-plaintext highlighter-rouge">snow_close_window</code>.</p>

<p>Here’s an example of what can be done right now:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;snow.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">window_t</span><span class="o">*</span> <span class="n">win</span> <span class="o">=</span> <span class="n">snow_open_window</span><span class="p">(</span><span class="s">"A static window"</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="n">WM_NORMAL</span><span class="p">);</span>

    <span class="n">snow_draw_window</span><span class="p">(</span><span class="n">win</span><span class="p">);</span> <span class="c1">// Draws the title bar and borders</span>
    <span class="n">snow_draw_string</span><span class="p">(</span><span class="n">win</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">,</span> <span class="s">"Lorem Ipsum"</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mh">0x00AA1100</span><span class="p">);</span>
    <span class="n">snow_draw_border</span><span class="p">(</span><span class="n">win</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">"Lorem Ipsum"</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mh">0x000000</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">snow_render_window</span><span class="p">(</span><span class="n">win</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">snow_close_window</span><span class="p">(</span><span class="n">win</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Giving this result:</p>

<figure>
    <img src="/assets/static_window.png" />
    <figcaption>that look has to change, I know</figcaption>
</figure>

<h3 id="implementation">Implementation</h3>

<h4 id="registering-a-window">Registering a window</h4>

<p>This means appending a given buffer to a list of windows to be drawn, and assigning it a z-order and unique id, a window being defined as</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_wm_window_t</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">_wm_window_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_wm_window_t</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">fb_t</span> <span class="n">fb</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">wm_window_t</span><span class="p">;</span>
</code></pre></div></div>
<p>This is my second use of intrusive lists in SnowflakeOS. I really ought to make a utility library to handle those, as I’ve had to write some very repetitive code in functions such as <code class="language-plaintext highlighter-rouge">wm_find_with_id</code>, <code class="language-plaintext highlighter-rouge">wm_find_with_flags</code> or <code class="language-plaintext highlighter-rouge">wm_find_with_z</code>. The lack of lambdas in C can really be felt in this situation.</p>

<h4 id="handling-z-order">Handling z-order</h4>

<p>This was less trivial than anticipated! Here’s how I handled it.
Z-orders are consecutive natural numbers, with 0 being the least visible window (e.g. a desktop background), and higher numbers being drawn on top of lower numbers.<br />
A newly opened window is assigned the highest z-order. When a window is closed, z-orders are shifted so that there is no gap between 0 and the highest z.<br />
Windows with a flag like <code class="language-plaintext highlighter-rouge">WM_FOREGROUND</code> will always stay on top of others, and similarly, those with <code class="language-plaintext highlighter-rouge">WM_BACKGROUND</code> fight for the lowest z-order.</p>

<p>I’m making things up as I go, to be honest. I’m sure I’ll figure out the good from the bad in due time :)</p>

<h4 id="drawing-a-full-frame">Drawing a full frame</h4>

<p><em>Edit: this is a poor implementation, see the next post for a better one.</em></p>

<p>The goal here is to draw windows in the correct z-order. Keeping in mind that window buffers are in the clients’ address spaces, we have at least two options:</p>
<ol>
  <li>at a regular interval, iterate over our windows in correct z-order, switch to their respective address space and copy their buffer to the screen</li>
  <li>when a client tells the WM that its window can be drawn, check if it’s their turn and if so draw them. Otherwise, lose a frame for that window.</li>
</ol>

<p>With option 1, I don’t know how to avoid drawing a window to the screen when its buffer may be in a “partially drawn” state, plus the method of switching address spaces is pretty barbaric, and I’m sure very slow.</p>

<p>I went for option 2, which I believe <a href="https://github.com/29jm/SnowflakeOS/blob/738c417d87460b82eafc2f9718ebc59b6c449de9/kernel/src/misc/wm.c">the code</a> can explain quite well:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">wm_render_window</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">win_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wm_window_t</span><span class="o">*</span> <span class="n">win</span> <span class="o">=</span> <span class="n">wm_get_window</span><span class="p">(</span><span class="n">win_id</span><span class="p">);</span>

    <span class="c1">// If it's not our turn, return</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">win</span><span class="o">-&gt;</span><span class="n">z</span> <span class="o">!=</span> <span class="n">current_z</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Render the window to the off-screen buffer</span>
    <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">fb</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">win</span><span class="o">-&gt;</span><span class="n">y</span><span class="o">*</span><span class="n">fb</span><span class="p">.</span><span class="n">pitch</span> <span class="o">+</span> <span class="n">win</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">*</span><span class="n">fb</span><span class="p">.</span><span class="n">bpp</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">win</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">win</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">win</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">.</span><span class="n">pitch</span><span class="p">),</span> <span class="n">win</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">.</span><span class="n">pitch</span><span class="p">);</span>
        <span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">off</span> <span class="o">+</span> <span class="n">fb</span><span class="p">.</span><span class="n">pitch</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// If all windows are drawn, write to the screen</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current_z</span> <span class="o">==</span> <span class="n">wm_get_max_z</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">current_z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">fb_render</span><span class="p">(</span><span class="n">fb</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">current_z</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Apart from dropping draw calls, this method has the downside that a slow client will slow the whole thing down: the WM will wait for its draw call and drop all others in the mean time.<br />
Good thing SnowflakeOS apps are always lightning fast ;)</p>

<h2 id="the-next-steps">The next steps</h2>

<p>In no particular order, this is what I want to get to:</p>
<ul>
  <li>cleaning up the code: these changes brought a lot of mess</li>
  <li>windows need to get keyboard and mouse events
    <ul>
      <li>a mouse pointer</li>
      <li>moving windows around</li>
      <li>porting my “Mandelbrot visualizer” app to SnowflakeOS</li>
    </ul>
  </li>
  <li>C++ support in userspace</li>
  <li>a GUI system</li>
</ul>

<h2 id="long-time-no-c">Long time no C</h2>

<p>It’s been a while since the last entry in this blog, but I’m hoping to pick up the pace. I’ve been very busy programming-wise with school projects, but less so now.<br />
One can’t reasonably spend their time writing C#, can they?</p>


  </div>

  <div class="date">
    Written on December 15, 2019
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/29jm"><i class="svg-icon github"></i></a>



<a href="/feed.xml"><i class="svg-icon rss"></i></a>




        </footer>
      </div>
    </div>

  </body>
</html>
